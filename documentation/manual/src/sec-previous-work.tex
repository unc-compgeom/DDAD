\section{Previous Work} 

A geometric workbench combines a geometric algorithm library with a geometric
algorithm visualizer. \emph{Geometric algorithm libraries} provide a broad
selection of algorithms and the substrate of types upon which they are built.
\emph{Geometric algorithm visualizers} provide a GUI capable of animating and
visually debugging those algorithms implemented in the library. They borrow
heavily from techniques used in general algorithm animation
systems~\cite{brown1984system, stasko1990tango, stasko1995polka,
stasko1995samba}. Previous works may thus be categorized as
libraries~\cite{mehlhorn1989leda, fabri1998design, overmars1996designing,
fabri1996cgal}, visualizers~\cite{phillips1993geomview, hanson1994interactive,
amenta1995geomview, basken2002geowin}, and full workbench
systems~\cite{schorn1991robust, de1993geolab, de1993animation,
epstein1994workbench, tal1995visualization, shneerson1997gasp,
wei2009geobuilder}. Our review focuses on the latter two.

\subsection{Geometric workbench systems}

\paragraph{XYZ GeoBench (1991)}

XYZ (eXperimental geometrY Zurich) GeoBench was a geometric workbench developed
by Peter Schorn under the supervision of Jurg
Nievergelt~\cite{schorn1991robust}. Schorn's 1991 thesis focused on the question
of how to produce good software for geometric computation, with a particular
emphasis on geometric robustness. Schorn describes the GeoBench as ``a
programming environment, implemented in an object oriented language, for the
rapid prototyping of geometric software and a testbed for experiments,'' noting
that ``algorithm animation is used for demonstration purposes and debugging.''
The XYZ Library was built on top of the GeoBench and offered implementations of
a large number of geometric algorithms.

There are several notable features about the GeoBench. The first is the use of
interchangable arithmetic and software simulation of parameterized floating
point numbers. In particular, algorithm implementations make reference to an
abstract 2D point class that does not specify a particular number system for the
coordinates. The abstract point class is extended to form concrete point types
for single-precision (realPoint), long integer (longIntPoint), and parameterized
floating point (floatPoint) coordinate types. Counterinuitively, the
parameterized floating point arithmetic was not used to ameliorate robustness
problems by increasing precision, rather it was used to simulate low precision
floating point to make the robustness problems more pronounced.

% The GeoBench had three major goals or desiderata. First was to be a programming
% environment. Provide the implementor of geometric algorithms with the necessary
% infrastructure for rapid prototyping. Ingredients of this environment include
% rich set of geometric primitives, fundamental set of basic geometric algorithms,
% collection of abstract data types and the ability to perform ``universal
% operations'' like input/output or scaling on geometric objects. Second was to be
% an interactive testbed for experiments. Wanted to measure an implementation's
% efficiency by comparing it to other programs solving the same problem. Would
% like to experiment with different implementations of abstract data structures
% and to try different models of arithmetic. Need to construct degenerate
% configurations as test cases and save them in a test suite. Third was algorithm
% animation. Most algos can be animated fairly easily since geometric objects have
% clear standard graphical representations. algo animation is used for
% demonstration in the classroom and for debugging.

\paragraph{Workbench (1991)}

Workbench is a system similar to XYZ GeoBench that focused on implementing
complex geometric algorithms instead of robustness
issues~\cite{epstein1994workbench}. The system is built in Smalltalk and
composed of three main components: a library, visualization GUI, and tools for
extending each. It focused heavily on empirical comparisons of different
algorithms and using animations for teaching and demonstration. They define the
minimum criteria for a geometric workbench as a system with: representations of
geometric objects, geometric data types, non-geometric data types, algorithmic
implementations that adhere to specification, different arithmetic types, and a
GUI that provides animation and debugging facilities.

% they identify two other projects (LEDA and GeoBench): LEDA had a large number of
% graph algorithms and well designed data types but was just then starting to move
% toward geometry, GeoBench is similar to workbench (UI + library) but main focus
% is on robust implementation of fundamental algorithms. the algorithmic portion
% of their software is layered with primitive operations and types on the bottom
% and more complex types on top. the ui component is separate and similarly
% layered. the primary goal of this project was to create a geometric computing
% environment: a tool for geometric computation applicable in a variety of
% contexts that provides useful facilities for dealing with the complex algorithms
% typical of computational geometry. they identify three main components such an
% environment must have: library of algs and data types, GUI for manipulating
% library objects, and tools for enhancing and extending the lib and GUI.
% empirical comparison of different algorithms and data structures is important,
% display and animation features are useful for teaching/demonstration. they
% consider the following worthwhile but didn't pursue them: optimizing
% implementations, handling degeneracies and numerical problems.
% 
% they define the minimum criteria for a geometry workbench as having:
% representations of geom objects (polygons etc), geometric data types/structures,
% nongeometric data types/structures (splay trees, heaps), algorithmic
% implementations adhering to specification, different arithmetic types, GUI with
% algorithm animation, programming environment and debugging facility (I/O of
% geometric objects). they implement the workbench in smalltalk

\paragraph{GeoLab (1993)}

de Rezende created GeoLab, a system that binds together support for software and
algorithm development with realtime interaction~\cite{de1993geolab,
de1993animation}. The system supports software development with built-in
abstract data types for geometric objects, data structures, basic algorithms,
and mechanisms for incorporating new components \emph{without} recompilation.
The system supports user interaction with the ability to construct input data,
debug implementations visually, gather statistics, input/output geometric data,
and customize algorithm animations. Although the system is implemented in
object-oriented C++, algorithms are not necessarily member functions of the
classes upon which they operate -- they may be free functions. This echoes
Meyer's advice that minimal use of member functions can often increase
encapsulation.

% software
% development:
% build in ADT's for geometric types, data structures, basic algorithms and some
% complex geometric data structures, mechanisms for incorporation of new
% components WITHOUT recompilation of the environment, etc.
% support for interaction: GUI, ability to construct input data, debugging and
% statistics, I/O, customization of algorithm animation. written in C++.

% new modules are imported into the system via shared libraries, the kernel itself
% contains no geometric code. GUI consists of editing area, operation pallete,
% algorithms menu. random generators for input data. double hierarchy of classes -
% pure objects and graphics objects. for each pure geometric object (e.g. point2d)
% there is a graphical geometric counterpart. geometric algorithms are not
% necessarily methods of the classes they operate on - they may be free functions.

\paragraph{GASP (1995)}

Tal and Dobkin describe the Geometric Animation System, Princeton
(GASP)~\cite{tal1995visualization}. The system allows users to quickly create 3D
visualizations, animate complex geometric algorithms, and visually debug
implementations. The use of style files to control the visual aspects of the
animation allows users to produce new renderings without recompiling the system.

% It can be used as an illustration tool for geometric
% constructions, to create videotapes to accompany talks, as a debugger, animator,
% and as an instructional aid to students. 

% three objectives set them apart from other
% animation systems such as Balsa Balsa-II Tango and Zeus: quick creation of 3d
% visulizations, can animate complex geometric algorithms, includes a visual
% debugging facility. the system may be used in many ways: illustration tool for
% constructions, videotapes to accompany talks/classes, for debugging, allow
% students to interact and experiment with animations, allows users to create
% animations to attach to their documents. previous systems identified two user
% types (client programmer and end user), they define three: end user, naive
% programmer (animations are easy), advanced programmer (can change the animation
% around). uses style files to control visual aspects of animations. thus, there
% are 4 parts to an animation: animation system, algorithm implementation, hooks
% to animation system inside implementation, style files. programmers concentrate
% on logical operations that need to be visualized (the what) but not how to do it
% (the how). identify four-dimensional space as future work.

%\paragraph{GASP-II (1998)}

%todo~\cite{shneerson1997gasp}.
% GASP-II had something to do with an electronic
% classroom~\cite{shneerson1997gasp}.

%\paragraph{WAVE (1999, 2001)}

%todo~\cite{baker1999visualizing, demetrescu2001visualizing}.

% tamassia and liotta got into visualizing geometric algorithms over the web in
% 1999 and 2001~\cite{baker1999visualizing, demetrescu2001visualizing}.

\paragraph{GeoBuilder (2009)}

GeoBuilder is a cross-platform geometric workbench written in
Java~\cite{wei2009geobuilder}. It features a novel mechanism for automatically
positioning the 3D camera during algorithm execution and allows users to
collaborate on programming and visualization. Wei et al demonstrate the 3D
tracking feature by constructing convex hulls and detecting line segment
intersections. They note that automatically positioning a single view of an
algorithm may not be sufficient to capture all changes in algorithm state, and
identify automatic positioning of multiple cameras for future work.

\subsection{Geometric algorithm libraries and visualizers}

\paragraph{LEDA}

The library of efficient data structures and algorithms (LEDA) is often
mentioned in the context of workbenches.

\paragraph{CGAL}

The computational geometry algorithms library (CGAL) is the current standard
implementation among the geometry community - it used to provide support for
GeomView but now just has its own visualization module.

\paragraph{Geomview}

Geomview is a geometric visualization system that focuses on rendering and
manipulating geometric data in 3-space~\cite{phillips1993geomview,
hanson1994interactive, amenta1995geomview}. It is able to render both static
geometry and dynamic geometry produced by an external program running
concurrently. External programs that use Geomview in this fashion are called
``external modules.'' It gained a large userbase after its initial release in 1991
due to its decoupled approach to animating geometric algorithms; users could
implement algorithms however they wanted and simply interface with Geomview at
runtime. Of particular note is its 4D visualization module that allow users to
explore 4-dimensional geometry through various projections. CGAL provides a
module for producing Geomview visualizations.

\paragraph{GeoWin}

GeoWin is a C++ data type that provides the ability to visualize sets of
geometric objects, with a focus on two dimensions~\cite{basken2002geowin}. This
functionality may be used to visualize the output of geometric algorithms or to
animate the progression of algorithms. GeoWin defines a programming interface to
define scenes and an interactive interface to define how the user may interact
with the scene. The data type integrates directly with LEDA and CGAL while
custom libraries must implement the interfaces, entailing a dependency on LEDA
types.
