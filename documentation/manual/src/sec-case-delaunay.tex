%==============================================================================
% @author Clinton Freeman <freeman@cs.unc.edu>
% @date 2014-11-26
%==============================================================================

\FloatBarrier
\section{Case Study: Randomized Incremental Delaunay Triangulation}
\label{sec:case-delaunay}

In this section, we use the workbench to implement and visualize a randomized
incremental Delaunay triangulation algorithm~\cite{lischinski1994incremental}.
We use the algorithm to construct \emph{polyhedral terrains}, or graphs of
continuous functions that are piecewise linear. The algorithm takes as input a
special point set called a terrain. A \emph{terrain} is a 2-dimensional surface
in 3-dimensional space with a special property: every vertical line intersects
it in a point, if it intersects it at all. The algorithm produces as output a
triangulation that is \emph{Delaunay}: the circumcircle of any triangle in the
triangulation does not contain any input points in its interior. 

\begin{figure}[htb]
\centering
\shadowimage[width=\textwidth]{figures/delaunay-terrain-intro} 
\caption{A polyhedral terrain produced by the workbench.}
\label{fig:terrain-intro} 
\end{figure}

Our workbench already has a simple point set type
(\texttt{PointSet\_3r}), but we will need to introduce a new type 
(\texttt{Terrain\_3r}) and visualize its methods in order to animate the
algorithm. The algorithm uses the quad-edge data
structure~\cite{guibas1985primitives} to store and manipulate terrain topology.
After explaining how the algorithm and data structure work, we use Heckbert's
QuadEdge C++ library to implement \texttt{Terrain\_3r} and use it to arrive at a
correct implementation of incremental Delaunay. We conclude by using the GUI to
generate an input point set and run the algorithm.

%==============================================================================

\subsection{Algorithm Overview}

The algorithm starts with an initial triangle, constructed such that it contains
all input points and is large enough to not affect the points' triangulation.
Points are inserted one at a time in a random order. Each insertion maintains
the invariant that the triangulation is Delaunay. There are three steps to
inserting a point $p$: localizing $p$ to a triangle $T$, inserting $p$ into
$T$, and restoring the Delaunay invariant. The insertion is a constant time
operation that adds three new edges from the triangles vertices to $p$. Below,
we describe localizing $p$ and restoring the invariant.

We start by finding the triangle that contains $p$. We could achieve optimal
$O(\log n)$ time, but this requires maintaining a complicated data structure.
Instead, we use the naive strategy of iterating over all triangles,
performing containment tests.  This strategy is incredibly easy to implement and 
- if the points are randomly chosen from a uniform distribution - only requires
$O(n^{1/2})$ operations in expectation. Once we locate $T$, we insert $p$ and
move to restore the Delaunay invariant.

We restore the invariant through a series of edge flips. Let $T = abc$ be the
old Delaunay triangle containing $p$, with circumcircle $C$. Then the new edges
$\seg{pa}$, $\seg{pb}$, and $\seg{pc}$ are Delaunay: the circle passing through
$p$ and tangent to $C$ at $a$ is a site-free witness for the Delaunayhood of the
edge $\seg{pa}$ (we can argue analogously for $\seg{pb}$ and $\seg{pc}$). The
edges $\seg{ab}$, $\seg{ac}$, $\seg{bc}$ are {\em suspect} since we do not know
if they pass the \textsc{InCircle} test with respect to $p$ and the triangle on
their other side. We have to check these suspect edges; if an edge fails the
\textsc{InCircle} test then it will be swapped, creating a new Delaunay edge
emanating from $p$ and creating two new suspect edges that must now be tested.
This process continues recursively until the invariant is restored.

%==============================================================================

\FloatBarrier
\subsection{The Quad-edge Data Structure}

The algorithm operates on the quad-edge data structure, which can be used to
represent planar subdivisions or manifold polytopes in 3D. The quad-edge is an
easy to use alternative to the earlier winged-edge data structure by
Baumgart~\cite{baumgart1975polyhedron} that has the added benefit of
simulaneously representing a graph and its dual.
Guibas and Stolfi describe the quad-edge structure in great
detail~\cite{guibas1985primitives}; for our purposes we can just familiarize
ourselves with the high level API provided by Heckbert's C++ quad-edge library.

In the quad-edge data structure, there are classes for vertices, edges, and
faces, but edges play the leading role. The edges store complete topological
information; all of the topological information stored by the faces and vertices
is redundant with information in the edges. The \texttt{Edge} class represents a
directed edge. Given \texttt{Edge *e}, you can find the immediately adjacent
vertices, faces, and edges, and the ``symmetric'' edge that points in the
opposite direction. These operators are all fast (just a few memory references).
Because edges are oriented, we can speak of the origin and destination vertices
and left and right faces of an edge. Figure \ref{fig:quadedge-edge-api}
summarizes the \texttt{Edge} API.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{figures/quadedge-edge-api} 
	\caption{derp}
	\label{fig:quadedge-edge-api} 
\end{figure}

% \begin{itemize}
%   \item \texttt{Vertex *e->Org()} - vertex at the origin of \texttt{e}
%   \item \texttt{Vertex *e->Dest()} - vertex at the destination of \texttt{e}
%   \item \texttt{Face *e->Left()} - face on the left of \texttt{e}
%   \item \texttt{Face *e->Right()} - face on the right of \texttt{e}
% \end{itemize}

The \texttt{Vertex} and \texttt{Face} classes are simple. The information stored
at a vertex consists of one piece of topological information (a pointer to one
of the outgoing edges of the vertex), plus geometric information (the (x, y, z)
position), and optional attribute information (color, normals, etc). Each face
stores one piece of topological information, a pointer to one of the
ccw-oriented edges of the face, plus optional attribute information (color, etc).

The \texttt{Cell} class models a single subdivision, which includes sets of
vertices, edges, and faces. The routines you will need most are those depicted
in figure \ref{fig:quadedge-cell-api}. These are called Euler operators, since
they maintain Euler's formula $V-E+F=2$ interrelating the number of vertices,
edges, and faces of a planar graph. If the topology is a valid graph before the
call, it will be valid after the call, as well.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{figures/quadedge-cell-api} 
	\caption{derp}
	\label{fig:quadedge-cell-api} 
\end{figure}

\begin{itemize}
  \item \texttt{c->makeVertexEdge(v, left, right)} splits vertex \texttt{v},
  creating a new edge and vertex that both lie between faces \texttt{left} and
  \texttt{right}. The new edge has \texttt{left} on its left and \texttt{right}
  on its right, \texttt{v} at its origin and the new vertex at its destination.
  The new edge is returned; the new vertex is easily found by taking
  \texttt{Dest()} of the return value. The new vertex and edge are stored in the
  sets associated with cell \texttt{c}. If \texttt{left} and \texttt{right} are
  not adjacent to \texttt{v} then an error message will be printed and core
  dumped.
  \item \texttt{c->makeFaceEdge(f, org, dest)} is the dual of this. It splits
  face \texttt{f}, creating a new edge and face that both lie between vertices
  \texttt{org} and \texttt{dest}. The new edge has \texttt{org} as its origin
  and \texttt{dest} as its destination, \texttt{f} as its left face and the new
  face as its right face. The new edge is returned; the new face is easily found
  by taking \texttt{Right()} of the return value. The new face and edge are
  stored in the sets associated with cell \texttt{c}. If \texttt{org} and
  \texttt{dest} are not adjacent to \texttt{f} then an error message will be
  printed and core dumped.
  \item \texttt{c->killVertexEdge(e)} is the inverse of \texttt{makeVertexEdge}.
  It removes edge \texttt{e} and vertex \texttt{e->Dest()}. Thus,
  \texttt{c->killVertexEdge(c->makeVertexEdge(v, left, right))} is a no-op.
  \item \texttt{c->killFaceEdge(e)} is the inverse of \texttt{makeFaceEdge}. It
  removes edge \texttt{e} and face \texttt{e->Right()}. Thus,
  \texttt{c->killFaceEdge(c->makeFaceEdge(f, org, dest))} is a no-op.
\end{itemize}





% but for our purposes we need only to understand the basic elements of the data
% structure (vertices, edges, and faces), and a few key operations
% (MakeVertexEdge, MakeFaceEdge, and their inverses.) 
% 
% Edges represent directed edges and are the most important element of the
% quad-edge data structure. They store pointers to their source and destination
% vertices, the faces to their left and to their right, symmetric edges, and
% other information.

\lstinputlisting[float, caption=Visualizing MakeVertexEdge,
label=delaunay-makevertexedge]{code-samples/delaunay-makevertexedge.cpp}

\lstinputlisting[float, caption=Visualizing MakeFaceEdge,
label=delaunay-makefaceedge]{code-samples/delaunay-makefaceedge.cpp}

\FloatBarrier
\subsection{Algorithm Implementation}
 
The incremental DT algorithm involves one geometric object (a subdivision), and
requires a single degree-four predicate to check whether a point is in, on, or
outside the circle defined by three points. The DDAD workbench provides the
geometric type (\texttt{Subdivision\_2r}) and the predicate
(\texttt{InCircle\_2r}).  

\lstinputlisting[float, caption=Incremental Delaunay Implementation,
label=delaunay-function]{code-samples/delaunay-terrain.cpp}

\lstinputlisting[float, caption=Adding a Sample,
label=delaunay-add-sample]{code-samples/delaunay-add-sample.cpp}

\lstinputlisting[float, caption=Locating a Point,
label=delaunay-locate-point]{code-samples/delaunay-locate-point.cpp}

\lstinputlisting[float, caption=Flipping Edges,
label=delaunay-test-and-swap-edges]{code-samples/delaunay-test-and-swap-edges.cpp}

%==============================================================================

\subsection{Generating Input Data and Executing Incremental Delaunay} 
