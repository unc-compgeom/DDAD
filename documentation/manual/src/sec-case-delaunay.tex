%==============================================================================
% @author Clinton Freeman <freeman@cs.unc.edu>
% @date 2014-11-26
%==============================================================================

\FloatBarrier
\section{Case Study: Randomized Incremental Delaunay Triangulation}
\label{sec:case-delaunay}

In this section, we use the workbench to implement and visualize a randomized
incremental Delaunay triangulation algorithm~\cite{lischinski1994incremental}.
We use the algorithm to construct \emph{polyhedral terrains}, or graphs of
continuous functions that are piecewise linear. The algorithm takes as input a
special point set called a terrain. A \emph{terrain} is a 2-dimensional surface
in 3-dimensional space with a special property: every vertical line intersects
it in a point, if it intersects it at all. The algorithm produces as output a
triangulation that is \emph{Delaunay}: the circumcircle of any triangle in the
triangulation does not contain any input points in its interior. 

\begin{figure}[htb]
\centering
\shadowimage[width=\textwidth]{figures/delaunay-terrain-intro} 
\caption{A polyhedral terrain produced by the workbench.}
\label{fig:terrain-intro} 
\end{figure}

Our workbench already has a simple point set type
(\texttt{PointSet\_3r}), but we will need to introduce a new type 
(\texttt{Terrain\_3r}) and visualize its methods in order to animate the
algorithm. The algorithm uses the QuadEdge data
structure~\cite{guibas1985primitives} to store and manipulate terrain topology.
After explaining how the algorithm and data structure work, we use Heckbert's
QuadEdge C++ library to implement \texttt{Terrain\_3r} and use it to arrive at a
correct implementation of incremental Delaunay. We conclude by using the GUI to
generate an input point set and run the algorithm.

%==============================================================================

\subsection{Algorithm Overview}

The algorithm starts with an initial triangle, constructed such that it contains
all input points and is large enough to not affect the points' triangulation.
Points are inserted one at a time in a random order. Each insertion maintains
the invariant that the triangulation is Delaunay. There are three steps to
inserting a point $p$: localizing $p$ to a triangle $T$, inserting $p$ into
$T$, and restoring the Delaunay invariant. The insertion is a constant time
operation that adds three new edges from the triangles vertices to $p$. Below,
we describe localizing $p$ and restoring the invariant.

We start by finding the triangle that contains $p$. We could achieve optimal
$O(\log n)$ time, but this requires maintaining a complicated data structure.
Instead, we use the naive strategy of iterating over all triangles,
performing containment tests.  This strategy is incredibly easy to implement and 
- if the points are randomly chosen from a uniform distribution - only requires
$O(n^{1/2})$ operations in expectation. Once we locate $T$, we insert $p$ and
move to restore the Delaunay invariant.

We restore the invariant through a series of edge flips. Let $T = abc$ be the
old Delaunay triangle containing $p$, with circumcircle $C$. Then the new edges
$\seg{pa}$, $\seg{pb}$, and $\seg{pc}$ are Delaunay: the circle passing through
$p$ and tangent to $C$ at $a$ is a site-free witness for the Delaunayhood of the
edge $\seg{pa}$ (we can argue analogously for $\seg{pb}$ and $\seg{pc}$). The
edges $\seg{ab}$, $\seg{ac}$, $\seg{bc}$ are {\em suspect} since we do not know
if they pass the \textsc{InCircle} test with respect to $p$ and the triangle on
their other side. We have to check these suspect edges; if an edge fails the
\textsc{InCircle} test then it will be swapped, creating a new Delaunay edge
emanating from $p$ and creating two new suspect edges that must now be tested.
This process continues recursively until the invariant is restored.

%==============================================================================

\FloatBarrier
\subsection{The QuadEdge Data Structure}

\lstinputlisting[float, caption=Visualizing MakeVertexEdge,
label=delaunay-makevertexedge]{code-samples/delaunay-makevertexedge.cpp}

\lstinputlisting[float, caption=Visualizing MakeFaceEdge,
label=delaunay-makefaceedge]{code-samples/delaunay-makefaceedge.cpp}

\FloatBarrier
\subsection{Algorithm Implementation}
 
The incremental DT algorithm involves one geometric object (a subdivision), and
requires a single degree-four predicate to check whether a point is in, on, or
outside the circle defined by three points. The DDAD workbench provides the
geometric type (\texttt{Subdivision\_2r}) and the predicate
(\texttt{InCircle\_2r}).  

\lstinputlisting[float, caption=Incremental Delaunay Implementation,
label=delaunay-function]{code-samples/delaunay-terrain.cpp}

\lstinputlisting[float, caption=Adding a Sample,
label=delaunay-add-sample]{code-samples/delaunay-add-sample.cpp}

\lstinputlisting[float, caption=Locating a Point,
label=delaunay-locate-point]{code-samples/delaunay-locate-point.cpp}

\lstinputlisting[float, caption=Flipping Edges,
label=delaunay-test-and-swap-edges]{code-samples/delaunay-test-and-swap-edges.cpp}

%==============================================================================

\subsection{Generating Input Data and Executing Incremental Delaunay} 
