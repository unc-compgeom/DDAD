%==============================================================================
% @author Clinton Freeman <freeman@cs.unc.edu>
% @date 2014-05-23
%==============================================================================

\FloatBarrier
\section{Case Study: Melkman's Algorithm}

This section examines using our workbench to animate Melkman's convex hull
algorithm. By providing a concrete example we hope to illuminate the major steps
required to animate algorithms in general. Before we get started, let us briefly
examine the algorithm in question.

\subsection{Algorithm Overview}

A \emph{polyline} $P$ is a polygonal chain of vertices $p_1, p_2, \ldots, p_n$
connected by line segments $p_ip_{i+1}$ for $1 \leq i < n$. $P$ is \emph{simple}
if the only intersection between segments is at their shared endpoints.
Melkman's algorithm incrementally computes the convex hull of a simple polyline
in $O(n)$ time~\cite{melkman1987line}. It can also be used to compute the convex
hull of arbitrary point sets if we first sort by $x$ coordinate, breaking ties
by $y$ coordinate.

Given an oriented line $pq$ and a point $r$, the 2D orientation predicate
$\textsc{Orient2D}(p, q, r)$ answers the question, ``is $r$ to the left, right,
or on $pq$?'' It is often written as the sign of the 2-by-2 determinant, $$
\textsc{Orient2D}(p, q, r) = \textsc{Sign}\left( \begin{vmatrix} p_x-r_x &
p_y-r_y \\ q_x-r_x & q_y-r_y \end{vmatrix} \right).$$

% Incremental convex hull algorithms construct the hull by examining each input
% point in turn, exploiting structure in the partial hull to help reduce
% computation. 
% Graham and Yao observed that if we know the points in advance, we
% may make our task easier by considering them in sorted order by $x$ coordinate,
% breaking ties by $y$ coordinate. Then point $p_i$ will always be a vertex of the
% convex hull $\text{CH}(P_i)$, and it will either be adjacent to $p_{i-1}$ or
% will cause $p_{i-1}$ to be removed from $\text{CH}(P_i)$.

\begin{mdframed}[linecolor=white, backgroundcolor=algback, frametitle={Algorithm
Melkman}] \begin{algorithmic}[1]    
    \Require Simple polyline $P = \langle v_1, \ldots, v_m \rangle$.
    \Ensure $\text{CH}(P)$.
    \vspace{0.75em}
    \Procedure{Melkman}{$P$}
    \State $\text{CH}(P).push(v_2);$ $\text{CH}(P).push(v_1);$
    $\text{CH}(P).push(v_2);$ \Comment{Init hull}
    \For{$i=3\ldots m$}
    	\State derp 
    \EndFor
    \EndProcedure
\end{algorithmic}
\end{mdframed} 

% Animating an algorithm using the workbench is composed of a number of tasks,
% namely 
% \begin{itemize}
%   \item Implement input data structures and instrument them with visualization
%   code.
%   \item Optionally modify the GUI to allow the user to create instances of
%   the input data structure.
%   \item Implement output data structures and instrument them with visualization
%   code.
%   \item Implement predicates.
%   \item Implement the algorithm and instrument it with a small amount of
%   visualization code.
%   \item Optionally modify the GUI to allow the user to run the algorithm on
%   selected input data. 
% \end{itemize}

% \subsection{Data Structures}
% 
% polychain\_2r
% 
% polygon\_2r

\subsection{Code Listing}

\lstinputlisting{code-samples/melkman.cpp}

\subsection{Generating Input Data}

Create button and implement click handler. buttongroup to model mutually
exclusive input states.

define input states. configmanager singleton. 


Handle ortho widget mouse clicks
forward signals from ortho to scene observer




% Animating any algorithm begins with generating the appropriate input. In the
% case of Melkman's algorithm, we begin by creating a simple polyline. This is
% accomplished by the user clicking on points in the 2D top-down orthographic
% view. The user may choose to place integer vertex coordinates or turn off
% snapping so that vertex coords are floating point or rational coords.
% 
% 
% 
% \begin{lstlisting}
% Polygon_2r Melkman(const PolyChain_2r& P, Visual::IGeometryObserver* ge_obs) {
%     Polygon_2r CH_P;
% 
% 
%     return CH_P;
% }
% \end{lstlisting}