\section{Introduction}

The executions of algorithms on geometric data would seem to be presented most
naturally as animations. But what should be animated? When one looks closely
at a geometric algorithm, one finds different interpretations of what is being
done: points and lines may be compared by computing vector dot and cross
products, which involve arithmetic computation on the coordinate values of
points. An implementer or a presenter of an algorithm may be interested in
different levels of abstraction.

An algorithm \emph{implementer} must correct programming errors and handle
degenerate situations correctly. Traditional debuggers provide only textual or
numerical representations of geometric data structures, and generating
degenerate geometric input is a nontrivial task for which there is often little
assistance. 

An algorithm \emph{presenter} must convey their ideas to audiences of
researchers and students. Many presenters use static depictions and verbally
explain algorithm mechanics, a type of presentation that does not fully capture
the dynamic nature of geometric algorithms.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth]{figures/currentstate-2}
	\caption{Our workbench animates incremental terrain mesh generation.} 
	\label{fig:currentstate}
\end{figure}

A \emph{geometric workbench} aids algorithm implementers and presenters by
providing facilities to dynamically visualize geometric algorithms. Implementers
can visually inspect geometric relationships and properties of data structures,
quickly recognizing erroneous computations. Presenters can produce
animations of their algorithms, more clearly conveying essential
ideas to their audience. Both types of geometers can interactively control the
flow of execution and easily generate degenerate input data.

\emph{Degree-driven algorithm design} encourages robust geometric computing by
attempting to minimize an algorithm's arithmetic precision with its running time
and space~\cite{millman2012degree}. Millman built a C++ library (DDAD) to
facilitate implementing algorithms with low-degree predicates. Our workbench
extends DDAD with a visual event system and provides a standalone GUI that can
generate input data and render algorithm execution.
Figure~\ref{fig:currentstate} captures the workbench rendering a terrain mesh
built by incremental delaunay triangulation.

This paper explains the benefits of using the DDAD workbench as a platform for
implementing and presenting degree-driven geometric algorithms. In
section~\ref{sec:taxonomy-previousworks-desiderata}, we define a taxonomy for
workbench systems and use it to place our workbench in the context of previous
works. We study Melkman's algorithm in section~\ref{sec:case-melkman} to show
how to leverage existing DDAD types to implement a simple 2-dimensional
algorithm. The inner workings of these types are revealed in
section~\ref{sec:workbench-architecture}. We conclude by studying incremental
Delaunay triangulation to show how to implement a complex 3-dimensional
algorithm.

% This paper provides a guided introduction to the inner workings of the DDAD
% workbench. It is intended for people interested in degree-driven algorithm
% design and who would like to use the DDAD library to get started implementing
% algorithms. We start out by explaining

%[todo: paragraph overviewing the paper]

% Section 2 reviews previous work. Section 3 recalls a general framework for
% designing software visualization systems. Section 4 uses the framework to
% explain our workbench desiderata. Section 5 provides an architectural overview
% of the workbench and section 6 runs through a case study of animating a convex
% hull algorithm. Section 7 concludes by explaining how current workbench
% architecture supports our desiderata and identifies areas in which it can
% improve.

 